set encoding=utf-8
set nocompatible

let mapleader = ","

" Switch syntax highlighting on, when the terminal has colors
syntax on
filetype plugin indent on

set cursorline
set nu
set ruler
set tabstop=2
set expandtab
set foldmethod=indent
set shiftwidth=2
" foldlevel初始值，高于此值的fold会默认关闭
set foldlevelstart=4
" 搜索逐字符高亮
set hlsearch
set incsearch
set completeopt=menu,menuone,preview,noselect,noinsert

" 配置tag {{{
set tags=./.tags;
" }}}


" 配置gutentags {{{
" gutentags 搜索工程目录的标志，碰到这些文件/目录名就停止向上一级目录递归
let g:gutentags_project_root = ['.root', '.svn', '.git', '.hg', '.project']
" 所生成的数据文件的名称
let g:gutentags_ctags_tagfile = '.tags'
" 配置 ctags 的参数
let g:gutentags_ctags_extra_args = ['--fields=+niazS', '--extra=+q']
let g:gutentags_ctags_extra_args += ['--c++-kinds=+px']
let g:gutentags_ctags_extra_args += ['--c-kinds=+px']
let g:gutentags_ctags_exclude = ['node_modules']

set statusline+=%{gutentags#statusline()}
" }}}


" 配置NERDTree {{{
let NERDTreeShowHidden=1
noremap <C-n> :NERDTreeToggle<CR>
noremap <leader>e :NERDTreeFind<CR>
" }}}


" 配置ycm {{{
if !exists("g:ycm_semantic_triggers")
  let g:ycm_semantic_triggers = {}
endif
let g:ycm_semantic_triggers['typescript'] = ['.']
" }}}


" 配置ctrlp {{{
let g:ctrlp_map = '<c-p>'
let g:ctrlp_custom_ignore = '\v[\/](node_modules|(\.(swp|ico|git|svn)))$'
" }}}


" 配置tsuquyomi：不好用，有性能问题，而且可以被ale完美替代 {{{
" set ballooneval
"autocmd FileType typescript setlocal balloonexpr=tsuquyomi#balloonexpr()
"autocmd FileType typescript nmap <buffer> <Leader>t : <C-u>echo tsuquyomi#hint()<CR>
" }}}


" 配置ale {{{
nnoremap <leader>] :ALEGoToDefinition<CR>
nnoremap <leader>^ :ALEFindReferences<CR>
" ycm semantic completion does not quite work, so i'm gonna: use ale to do lint and
" semantic completion, use ycm to do tag based completion
let g:ale_completion_enabled = 1
" }}}


" 配置indentLine {{{
let g:indentLine_char_list = ['|', '¦', '┆', '┊']
" }}}


" key bindings {{{
nnoremap <leader>msg :messages<CR>
nnoremap <leader>ev :vsplit $MYVIMRC<CR>
nnoremap <leader>sv :source $MYVIMRC<CR>
" 练习
nnoremap <leader>g :silent execute "grep! -R " . shellescape(expand("<cword>")) . " ."<cr>:copen<cr>

" 编辑快捷键
" 快速保存
inoremap <Esc><Esc> <Esc>:w<CR>
" 关闭高亮
nnoremap <leader>nh :noh<CR>
" 向前/后跳转至{/}符号
map [[ ?{<CR>w99[{
map ][ /}<CR>b99]}
map ]] j0[[%/{<CR>
map [] k$][%?}<CR>

command! -nargs=1 CMDGoNextFold call GoNextFold(<args>)
command! -nargs=1 CMDGoPrevFold call GoPrevFold(<args>)
" 此处的c-u说是要清楚什么范围，没看懂文档;[
nnoremap <leader>zj :call :<C-U>CMDGoNextFold(v:count1)<CR>
nnoremap <leader>zk :call :<C-U>CMDGoPrevFold(v:count1)<CR>

function! GoNextFold(cnt)
  if a:cnt ==# 0
    return
  endif
  let l:initial_line = line('.')
  let l:lnum = foldclosedend(l:initial_line) + 1
  if l:lnum ==# 0
    let l:lnum = l:initial_line
  endif 
  let l:end_line = line('$')
  while foldclosed(l:lnum) ==# -1 && l:lnum <=# l:end_line
    let l:lnum += 1
  endwhile
  if l:lnum ># l:end_line
    return
  endif
  execute 'normal! ' . l:lnum . 'G'
  call GoNextFold(a:cnt - 1)
endfunction

function! GoPrevFold(cnt)
  if a:cnt ==# 0
    return
  endif
  let l:initial_line = line('.')
  let l:lnum = foldclosed(l:initial_line) - 1
  if l:lnum ==# -2
    let l:lnum = l:initial_line
  endif 
  let l:end_line = 1
  while foldclosed(l:lnum) ==# -1 && l:lnum >=# l:end_line
    let l:lnum -= 1
  endwhile
  if l:lnum <# l:end_line
    return
  endif
  execute 'normal! ' . l:lnum . 'G'
  call GoPrevFold(a:cnt - 1)
endfunction
" }}}


" 自定义命令 {{{
command! -nargs=+ -complete=file Gr call CGrepSourceCode(<f-args>)
command! -nargs=+ -complete=file Gr2 call GrepSourceCode(<f-args>)

function! CGrepSourceCode(...)
  let l:word = expand('<cword>')
  let l:args = a:000[0:]
  let l:prepended = reverse(add(reverse(l:args), l:word))
  call call(function('GrepSourceCode'), l:prepended)
endfunction

function! GrepSourceCode(...)
  execute 'grep -RE '
        \ . '--exclude-dir .git '
        \ . '--exclude-dir node_modules '
        \ . '--exclude-dir tmp '
        \ . '--exclude-dir build '
        \ . '--exclude-dir built '
        \ . join(a:000)
endfunction
" }}}


" 自动命令 ---------------------- {{{
augroup mygroup
  autocmd!
  autocmd FileType vim setlocal foldmethod=marker
  " 没有太大卵用 ;]
  "autocmd TextChangedI * call TryDetectFileType()
  "autocmd TextChanged * call TryDetectFileType()

  " 打开文件时光标自动定位到上次退出时的位置
  autocmd BufReadPost *
        \ if line("'\"") > 1 && line("'\"") <= line("$") && &ft !~# 'commit'
        \ |   exe "normal! g`\""
        \ | endif

  " 不好用
  " autocmd FileType python setlocal equalprg=~/Developer/python/utils/reindent.py
  " autocmd FileType python setlocal equalprg=autopep8\ -
augroup END

"第一行文字改变时立即检测ft
"function! TryDetectFileType()
"	if !exists("b:FirstLineContent")
"    let b:FirstLineContent = ""
"	endif
"  let l:FirstLineContent = getline(1)
"  if b:FirstLineContent !=# l:FirstLineContent
"    let b:FirstLineContent = l:FirstLineContent
"    filetype detect
"  endif
"endfunction
" }}}

